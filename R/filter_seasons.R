#' @title Filter growing seasons
#' @description Filter detected seasons basing on dates of begin / end / peak,
#'  and associate each season with a reference year.
#' @param seas Seasons allocation (data table generated by `extract_pheno()`
#'  or `cut_seasons()`).
#' @param pop_seasons Named list with the allowed ranges for the dates of
#'  seasonal peaks: each element is a character vector with two
#'  elements, in the form `"mm-dd"` (month-day), representing the range of the 
#'  temporal window (see default value as example).
#'  The number of elements is the maximum number of seasons accepted for each
#'  year ( in case of a higher number, the season with a higher `peak` value
#'  within each season name is maintained).
#' @param sos_seasons Named list with the allowed ranges for the dates of
#'  beginning of growing season: each element is a character vector with two
#'  elements, in the form `"mm-dd"` (month-day), representing the range of the 
#'  temporal window (see default value as example).
#'  If must be of the same length of `pop_seasons` and with the same names.
#' @param eos_seasons Named list with the allowed ranges for the dates of
#'  end of growing season: each element is a character vector with two
#'  elements, in the form `"mm-dd"` (month-day), representing the range of the 
#'  temporal window (see default value as example).
#'  If must be of the same length of `pop_seasons` and with the same names.
#' @param pop_metric Character name of the field in `seas` to be used as metric
#'  for the date of peak (associated with `pop_seasons`).
#' @param sos_metric Character name of the field in `seas` to be used as metric
#'  for the date of beginning of growing season (associated with `sos_seasons`).
#'  Set to NULL in order not to apply.
#' @param eos_metric Character name of the field in `seas` to be used as metric
#'  for the date of end of growing season (associated with `pop_seasons`).
#'  Set to NULL in order not to apply.
#' @param peak_metric Character name of the field in `seas` to be used as metric
#'  for the value of the peak.
#' @param newyear Character vector in the form `"mm-dd"` (month-day)
#'  representing the day from which a new year is considered.
#'  If it is in July or later, seasons with a peak after day `newyear` are
#'  associated with the subsequent year; otherwise, seasons with a peak before
#'  day `newyear` are associated with the previous year.
#' @return The input data table, filtered basing on arguments and with two
#'  more fields:
#'  - `seas_name`: the name of the season (corresponding to the name of one of
#'      the elements of argument `pop_seasons`);
#'  - `year`: the year associated to each season.
#' @author Luigi Ranghetti, PhD (2020) \email{luigi@@ranghetti.info}
#' @import data.table
#' @importFrom methods as
#' @importFrom phenopix PhenoExtract
#' @export

filter_seasons <- function(
  seas,
  pop_win = list("winter" = c("02-01","05-31"), "summer" = c("06-01","09-30")),
  sos_win = list("winter" = c("10-01","04-30"), "summer" = c("05-01","08-31")),
  eos_win = list("winter" = c("03-01","07-15"), "summer" = c("07-16","11-15")),
  pop_metric = "pop",
  sos_metric = "sos",
  eos_metric = "eos",
  peak_metric = "peak",
  newyear = "10-01"
) {
  
  #   ## Check arguments
  # TODO
  
  # # Which years are used
  # years <- range(as.integer(strftime(seas[[seas_metric]], "%Y")))
  # years <- seq(years[1], years[2])
  
  # # Filter seasons
  # if (is.null(names(seas_win))) {
  #   names(seas_win) <- as.character(seq_along(length(seas_win)))
  # }
  # seas_win_1 <- rbindlist(
  #   mapply(function(s, n) {
  #     if (package_version(s[1]) < package_version(s[2])) {
  #       data.frame(
  #         "seas_name" = n,
  #         "date_min" = apply(expand.grid(years,s[1]), 1, paste, collapse = "-"),
  #         "date_max" = apply(expand.grid(years,s[2]), 1, paste, collapse = "-")
  #       )
  #     } else {
  #       data.frame(
  #         "seas_name" = n,
  #         "date_min" = apply(expand.grid(c(years[1]-1,years),s[1]), 1, paste, collapse = "-"),
  #         "date_max" = apply(expand.grid(c(years,years[length(years)]+1),s[2]), 1, paste, collapse = "-")
  #       )
  #     }
  #   }, seas_win, names(seas_win), SIMPLIFY = FALSE, USE.NAMES = FALSE)
  # )
  
  # Assign the season name
  seas_dt <- copy(seas)
  for (s in names(pop_win)) {
    seas_dt[
      if (is.null(pop_win)) TRUE else do.call(
        if (package_version(pop_win[[s]][1]) < package_version(pop_win[[s]][2])) `&` else `|`, 
        list(
          package_version(strftime(get(pop_metric), "%m.%d"), strict = FALSE) >= package_version(pop_win[[s]][1]),
          package_version(strftime(get(pop_metric), "%m.%d"), strict = FALSE) <= package_version(pop_win[[s]][2])
        )) &
        if (is.null(sos_win)) TRUE else do.call(
          if (package_version(sos_win[[s]][1]) < package_version(sos_win[[s]][2])) `&` else `|`, 
          list(
            package_version(strftime(get(sos_metric), "%m.%d"), strict = FALSE) >= package_version(sos_win[[s]][1]),
            package_version(strftime(get(sos_metric), "%m.%d"), strict = FALSE) <= package_version(sos_win[[s]][2])
          )) &
        if (is.null(eos_win)) TRUE else do.call(
          if (package_version(eos_win[[s]][1]) < package_version(eos_win[[s]][2])) `&` else `|`, 
          list(
            package_version(strftime(get(eos_metric), "%m.%d"), strict = FALSE) >= package_version(eos_win[[s]][1]),
            package_version(strftime(get(eos_metric), "%m.%d"), strict = FALSE) <= package_version(eos_win[[s]][2])
          )),
      "seas_name" := s
      ]
  }

  # Assign year to seasons
  # if newyear > July 1st, the seasons with the peak after newyear are assigned
  # to the subsequent year;
  # otherwise, the seasons with the peak before newyear are assigned
  # to the previous year.
  newyear_doy <- as.integer(strftime(as.Date(paste0("2000-",newyear), format = "%Y-%m-%d"), "%j"))
  if (package_version(newyear) >= package_version("07.01")) {
    seas_dt[,year := as.integer(strftime(get(pop_metric)-newyear_doy, "%Y"))+1]
  } else {
    seas_dt[,year := as.integer(strftime(get(pop_metric)-newyear_doy, "%Y"))+1]
  }
  
  # Exclude undetected seasons
  seas_dt <- seas_dt[!is.na(seas_name),]
  
  # In case of multiple seasons of the same nale, keep the one with the highest peak
  seas_dt <- seas_dt[order(id, year, seas_name, -get(peak_metric)),]
  seas_dt <- seas_dt[seas_dt[,list(filter=!duplicated(seas_name)), by = list(id, year)]$filter,]
  
  # # Compute yearly statistics
  # seas_dt[,list(n_seas = .N), by = list(id, year)]

  seas_dt  

}
