#' @title Fit curve over seasons
#' @description Fit a curve using a parametric function  from 
#'  `phenopix::greenProcess()`.
#' @param ts Time series in `s2ts` format (generated using `fill_s2ts()`).
#' @param seas Seasons allocation (data table generated by `cut_seasons()`).
#' @param fit Fitting function among `"klosterman"`, `"beck"`,
#'  `"elmore"` and `"gu"` (see `phenopix::greenProcess()`).
#' @return A named list of `n` elements (being `n` the number of IDs included
#'  in `ts`). Each element is a named list of `m` elements (being `m` the
#'  number of detected seasons).
#'  Each element is a list including the following elements:
#'  - `fit`: the fitted curve as returned by `phenopix` fitting functions;
#'  - `ts`: a data table of fitted values, containing the columns
#'      `date` (date of the record) and
#'      `value` (fitted value);
#'  - `maxval`: the date of the maximum value in the season
#'      (reported from input `seas` and here reported).
#' @author Luigi Ranghetti, PhD (2020) \email{luigi@@ranghetti.info}
#' @import data.table
#' @importFrom zoo zoo
#' @importFrom phenopix KlostermanFit BeckFit ElmoreFit GuFit
#' @importFrom methods as
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @export


fit_curve <- function(
  ts,
  seas,
  fit = "gu"
) {
  
  
  ## Check arguments
  # TODO
  
  # Check fit
  fit.fun <- if (fit=="beck") phenopix::BeckFit else
    if (fit=="elmore") phenopix::ElmoreFit else
      if (fit=="klosterman") phenopix::KlostermanFit else
        if (fit=="gu") phenopix::GuFit else
          print_message(
            type = "error",
            "Argument 'fun' only accepts values \"klosterman\", \"beck\", ",
            "\"elmore\" and \"gu\"."
          )
  
  ## Check s2ts format
  # (must contain date, id, orbit, sensor, value, opt. quality)
  if (!inherits(ts, "s2ts")) {
    print_message(
      type = "error",
      "Argument 'ts' is not in the right format."
    )
  }
  # TODO
  ts_dt <- as.data.table(ts)
  
  # Check the frequency to be daily
  if (any(unique(ts_dt[,list(freq = diff(date)), by=id]$freq) != 1)) {
    print_message(
      type = "error",
      "Argument 'ts' must be a daily s2ts object, ",
      "generated with fill_s2ts(..., frequency = \"daily\")."
    )
  }
  
  # Compute relative values
  rescale <- ts_dt[,c(min(value, na.rm=TRUE), diff(range(value, na.rm=TRUE)))]
  ts_dt[,relval := (value - rescale[1]) / rescale[2]]
  
  # Set progress bar (time consuming function)
  use_pb <- inherits(stdout(), "terminal") && seas$dates[,length(unique(paste(id,season)))] > 1
  if (use_pb) {
    pb <- txtProgressBar(0, seas$dates[,length(unique(paste(id,season)))], style = 3)
  }
  
  # Fit for each ID/season
  fit_out <- list()
  for (sel_id in unique(ts_dt$id)) {
    
    fit_out[[sel_id]] <- list()
    for (sel_season in seas$dates[id == sel_id, unique(season)]) {
      sel_cut_date <- seas$dates[id == sel_id & season == sel_season,][match(c("begin", "maxval", "end"), pheno), date]
      sel_ts_zoo <- zoo::zoo(
        ts_dt[id == sel_id & date >= sel_cut_date[1] & date < sel_cut_date[3], relval]
      )
      sel_fit <- try(fit.fun(ts = sel_ts_zoo, uncert = FALSE))
      if (!inherits(sel_fit, "try-error")) {
        fit_out[[sel_id]][[as.character(sel_season)]] <- list(
          "fit" = sel_fit$fit,
          "ts" = data.table(
            "date" = ts_dt[
              id == sel_id & date >= sel_cut_date[1] & date < sel_cut_date[3], 
              date
              ],
            "value" = rescale[1] + as.numeric(sel_fit$fit$predicted) * rescale[2]
          ),
          "maxval" = sel_cut_date[2]
        )
      }
      if (use_pb) {setTxtProgressBar(pb, pb$getVal()+1)} # update progress bar
    } # end of sel_season FOR cycle
    
  } # end of id FOR cycle
  
  if (use_pb) {message("")} # separate progress bar
  
  attr(fit_out, "gen_by") <- "fit_curve"
  attr(fit_out, "info") <- list("fit" = fit, "rescale" = rescale)
  fit_out
  
}
