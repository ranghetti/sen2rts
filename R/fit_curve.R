#' @title Fit curve over seasons
#' @description Fit a curve using a parametric function  from 
#'  `phenopix::greenProcess()`.
#' @param ts Time series in `s2ts` format (generated using `fill_s2ts()`).
#' @param seas Seasons allocation (data table generated by `cut_seasons()`).
#' @param fit Fitting function among `"klosterman"`, `"beck"`,
#'  `"elmore"` and `"gu"` (see `phenopix::greenProcess()`).
#' @return The output time series in tabular format (see `extract_ts()`),
#'  with a new column `fit` containing fitted values.
#' @author Luigi Ranghetti, PhD (2020) \email{luigi@@ranghetti.info}
#' @import data.table
#' @importFrom zoo zoo
#' @importFrom phenopix KlostermanFit BeckFit ElmoreFit GuFit
#' @importFrom methods as
#' @export


fit_curve <- function(
  ts,
  seas,
  fit = "klosterman"
) {
  
  
  ## Check arguments
  # TODO
  
  # Check fit
  fit.fun <- if (fit=="klosterman") phenopix::KlostermanFit else
    if (fit=="beck") phenopix::BeckFit else
      if (fit=="elmore") phenopix::ElmoreFit else
        if (fit=="gu") phenopix::GuFit else
          print_message(
            type = "error",
            "Argument 'fun' only accepts values \"klosterman\", \"beck\", ",
            "\"elmore\" and \"gu\"."
          )
  
  ## Check s2ts format
  # (must contain date, id, orbit, sensor, value, opt. quality)
  if (!inherits(ts, "s2ts")) {
    print_message(
      type = "error",
      "Argument 'ts' is not in the right format."
    )
  }
  # TODO
  ts_dt <- as.data.table(ts)
  
  # Compute relative values
  ts_dt[,relval := (value - min(value, na.rm=TRUE)) / diff(range(value, na.rm=TRUE))]
  
  
  # Fit for each ID/season
  for (sel_id in unique(ts_dt$id)) {
    
    print(sel_id) # FIXME remove
    
    # cut_dates_c <- ts_dt[id == sel_id & pheno == "cut_seas", date]
    # cut_dates <- lapply(seq_along(cut_dates_c)[-1], function(i) {cut_dates_c[c(i-1,i)]})
    
    for (sel_season in seas[id == sel_id, unique(season)]) {
      print(sel_season) # FIXME remove
      sel_cut_date <- seas[id == sel_id & season == sel_season,][match(c("begin", "end"), pheno), date]
      sel_ts_zoo <- zoo::zoo(
        ts_dt[id == sel_id & date >= sel_cut_date[1] & date < sel_cut_date[2], relval]
      )
      sel_ts_fit <- try(fit.fun(ts = sel_ts_zoo, uncert = FALSE))
      if (!inherits(sel_ts_fit, "try-error")) {
        ts_dt[
          id == sel_id & date >= sel_cut_date[1] & date < sel_cut_date[2],
          c("season", "relval_fit") := list(sel_season, as.numeric(sel_ts_fit$fit$predicted))
          ]
      }
    } # end of cut_date FOR cycle
    
  } # end of id FOR cycle
  
  ts_dt[,value := min(value, na.rm=TRUE) + relval_fit * diff(range(value, na.rm=TRUE))]
  
  ts_out <- as(ts_dt[!is.na(value), list(id, date, season, value)], "s2ts")
  attr(ts_out, "gen_by") <- "fit_curve"
  attr(ts_out, "fit") <- fit
  ts_out
  
}
